---
title: Back To The Basic
date: 2019-06-21 00:00:00 +0300
description: 
cover: /assets/post_img/back-to-the-basic_title.PNG
tags: 
---
<center><img src="{{site.baseurl}}/assets/post_img/back-to-the-basic_title.PNG"></center>
<div style="text-align: center;">
    <span style="font-size:11px; color:grey">
        이 정적 페이지는 PC 버전에 최적화가 되어 있습니다.  
    </span>
</div>

## 개요
주니어 개발자로서 모르거나 명확하게 알지 못했던 개념을 정리한 페이지입니다.

## TL;DR;
컴퓨터에서 가장 중요한 요소는 AMD, ARM, Intel 등의 제조사에서 CPU라고 생각합니다.   
CPU 프로세서는 메모리에 올라온 프로그램(프로세스)를 읽어 수행하며 프로그램은 기계어 (ex.   10010101) 형식으로 구성되어야 합니다.  
따라서 프로그래머가 짜는 printf 등의 구문은 고수준의 언어로 컴퓨터는 알아 볼 수 가 없기 때문에 기계어로 변환되는 작업이 필요하고 이러한 작업을 컴파일이라고 부릅니다.  
컴파일을 수행하는 컴파일러에는 gcc jvm 등이 있습니다.   
어셈블리어는 기계어의 바로 한 단계 위로 기계어와 1:1로 매칭이 됩니다.   (ex, MOV - 10010101)  
CPU는 GPU에게 렌더링 등 그래픽 관련된 연산의 권한을 위임하며 GPU는 주로 곱연산 등에 CPU보다 월등한 성능을 발휘합니다.  
일반적으로 Draw Call 명령은 적게 할 수록 좋습니다.  
CPU와 GPU간의 컨텍스트 스위칭 등으로 인해 성능 이슈가 발생하기 때문입니다.  
모바일 어플리케이션에는 크게 구글의 안드로이드 OS와 애플의 IOS가 존재합니다.    
만든 프로그램이 운영체제에서 실행되기 위해선 모바일 OS가 알아들을 수 있는 형태를 가져야합니다.  
예를 들면 안드로이드 운영체제는 java 기반의 VM을 사용하기 때문에 C/C++ 등 언어로 짜여진 소스 코드는 별도의 빌드 툴의 도움을 받아야 합니다.   
Android NDK로 C 및 C++ 코드 를 네이티브 라이브러리로 컴파일하고 IDE의 내장 빌드 시스템인 Gradle을 사용하여 APK로 패키징할 수 있습니다.  
자바 코드(MainActivity.java) 등에서 JNI(Java Native Interface) 프레임워크를 통해 네이티브 라이브러리에 포함된 함수를 호출할 수 있습니다.  

안드로이드 마켓은 앱 출시 후 검사의 로직을 앱스토어는 선 검사 후 출시의 로직을 가집니다.  

## 클러스터링과 로드밸런싱
www.naver.com이라는 웹 사이트가 있습니다.  
이 사이트는 DNS를 통해 실제 웹 서버인 xx.xx.xx.xx로 요청을 보냅니다.  
클라이언트는 서버로부터 받은 데이터를 출력합니다.  
위의 상황은 일반적 웹이 동작하는 방식입니다.  
만약, www.wonhee.com으로의 접속 요청이 많아진다면
서버에 부하가 걸릴 수 있습니다.  
서버의 통신 회선 전송 속도가 1Gbps로 가정한다면,
하나의 회선으로 여러 클라이언트에게 데이터를 주고 받는데 한계가 있을 수 밖에 없습니다.
또한, 수 많은 요청에 대한 응답은 서버 환경에 따라 지연이 걸릴 수 있습니다.
이처럼 많은 클라이언트의 요청에도 빠르게 응답하기 위해 존재하는 것이 클러스터링입니다.
쉽게 말하면 서버를 분산하는 것입니다. 기존에 컴퓨터가 1대였다면 10대로 늘렸다고 가정합니다.
이렇게 된다면 1대의 컴퓨터가 하는 연산 처리가 10대에서 나눠서 하기 때문에
많은 요청에도 빠르게 응답할 수 있습니다. 또한, 10대 중 1대의 컴퓨터가 장애가 생겼을 경우
다른 컴퓨터가 처리해주면 되므로 서비스 장애에 대비할 수 있습니다.
이렇게 여러 대의 서버 장비(컴퓨터)를 연결하여 병렬 시스템으로 구성하여 서버 한대가 동작하는 것처럼 구성하는 것을 클러스터링이라고 말합니다.  
기본적으로 www.wonhee.com은 xx.xx.xx.xx의 주소로 매핑됩니다. 
클라이언트가 요청을 보내는 서버는 한대인데 분산처리는 어떻게 할까요?
로드밸런싱은 중앙 서버에서 할일을 병렬로 연결되어 있는 여러 서버로 분산하는 역할을 수행합니다. 이러한 작업을 하는 SW 혹은 HW를 로드밸런서라 부릅니다.
로드 밸런서는 요청을 받아 분산 서버들의 상태를 확인하고 클러스터링 된 서버에 나누어 줍니다.
이러한 서비스 요청을 위해 HAProxy가 자주 사용된다고 합니다. 요즘에는 nginx나 apache 등에서도 로드밸런싱을 지원한다고 합니다.

위에서 말씀드린 로드 밸런싱과 클러스터링은 모두 scale out 방식입니다.
capacity가 5인 서버를 10으로 올리는 것이 아닌
capactiy를 하나 더 추가하는 것입니다.
A = 5일때, 
A = A + 5 가 아닌 
A = A + A 라는 말입니다.
기존의 것을 건드리지 않고 수평 노드를 추가함으로 써 비용이 효율적이라고 합니다.
 
## 샤딩과 파티셔닝
마찬가지로 www.wonhee.com이라는 웹 사이트가 있습니다.  
인기가 많아져서 많은 회원을 보유하게 되었습니다.  
언제부턴가 사이트의 로그인 하는데 시간이 많이 걸립니다.  
고객의 정보가 존재하는 DB의 테이블이 많아지거나 테이블의 로우가 많아서 데이터를 가져오는 데
시간이 기존보다 오래 걸려 발생하는 현상입니다.  
대용량 처리를 위해 카산드라나 다이나모같은 애초에 대용량 분산 환경을 고려하여 만들어진 DB도 있지만
JOIN 연산을 사용할 수 없고 트랜잭션도 지원하지 않습니다. 
RDBMS + 샤딩으로 다양한 기능을 사용하면서 데이터를 확장하는 원리에 대해 알아보겠습니다.
기본 개념은 데이터를 여러 테이블에 나눠 저장함으로써 각 테이블에 대한 성능을 보장하는 것입니다.

user라는 테이블이 있다고 가정합니다.
회원이 100명일 때는 로우가 100 뿐이었지만 어느새 회원이 10000명이 되어 로우가 증가하였습니다.  
한 테이블에 만 개의 데이터를 저장하기 보다는 10개의 테이블에 나눠서 저장한다면 CRUD 연산 시 더 빠른 성능을 기대할 수 있습니다.  
위처럼 같은 테이블 스키마를 가진 데이터를 분산하여 저장하도록 구성하는 것을 샤딩이라고 합니다.  
일반적인 샤딩은 샤딩 키를 해싱하여 동작합니다.  
아래와 같은 user 테이블이 존재합니다.  

user_id | name | level
--------|------|-----
1|토끼|47|
2|거북이|23|
3|두꺼비|11|
4|개구리|22|
..|......|...|
10001|호랑이|99|

해시 샤딩은 단순하게 id 혹은 pk를 통해 샤딩합니다.
위 테이블에서는 user_id를 기준으로 아래와 같이 동작합니다.
```
switch (user_id % 100)
    case0: INSERT INTO ~ ... user_00
    case1: INSERT INTO ~ ... user_01
    case2: INSERT INTO ~ ... user_02
     ...
    case99: INSERT INTO ~ ... user_99
break
```
다시 말해 샤딩은 테이블의 로우들을 나눠서 저장하는 것입니다.
따라서 수평 파티셔닝이라고 말할 수 있습니다.
그에 반해 수직 파티셔닝은 row가 아닌 column을 기준으로 나눕니다.
위에서 본 테이블을 기준으로 수직 파티셔닝은 

user_id | level
--------|-----
1|47
2|23
3|11
4|22
..|..
10001|99

이런 방식으로 동작합니다.

샤딩은 테이블 간의 조인 연산 및 트랜잭션이 불가능합니다.
또한 지나친 샤딩은 테이블 개수를 늘려 오히려 성능에 악영향을 줄 수 있습니다.
이에 따라 초기에 설계가 매우 중요하다고 볼 수 있습니다.

## 컴파일과 인터프리터
프로그래밍 언어(high-level)를 통해 개발한 소스 코드는 컴퓨터가 알아볼 수 있게 low-level으로 번역되어야 합니다.  
컴파일은 소소 코드 전체를 번역하여 목적 파일을 생성한다. 다만, 생성된 파일은 실행할 수 없고 실행을 위해선 링커가 실행 파일로 만들어 주어야합니다.  
또한 번역된 기계어는 CPU나 OS마다 다르게 해석할 수 있어 컴파일러가 제각각일 수 있습니다.  
Java의 컴파일러는 소스 코드를 기계어가 아닌 바이트 코드로 변환한다. JVM은 이러한 바이트 코드를 해석하여 기계어로 바꿀 수 있기 때문에 OS나 CPU에 독립적이지만 그만큼 속도가 느립니다.  
인터프리터는 소스 코드 번역 없이 프로그램이 실행되는 환경에서 즉시 실행됩니다. 이에 따라 기계어로 따로 변환하는 작업이 필요없습니다.  
하지만 프로그램에 인터프리터가 있어야만 실행이 가능합니다. 또한 프로그램 디버깅이 어렵습니다.  
JIT(JustInTime)는 컴파일러와 인터프리터의 특징이 혼합되었습니다. 프로그램이 실행될 때 컴파일하여 사용되는 구조입니다.  
## 매개변수와 전달인자
매개변수(parameter)는 실제 값이 존재하지 않습니다. (함수 정의부)  
전달인자(argument)는 실제 값이 존재합니다. (함수 호출부)  
일반적으로 프로그램이 실행되어 CPU가 PC를 통해 코드를 읽어나갈 때  
정의부에서 파라미터를 위한 미리 메모리를 할당해두고 실제로 호출되어  
인자를 받을 때 미리 할당한 메모리에 저장하는 것입니다.  
## 객체 지향 프로그래밍(Object Oriented Programming)
프로그래밍에는 다양한 기법이 있습니다.  
그 중 OOP는 실제의 사물을 그대로 나타내려는 것에 중점을 둔 방식입니다.  
다시 말해 사물을 추상화하여 캡슐화하고 계층을 상속시키고 다른 특성이나 행위는 다형성으로 구현하여 프로그램을 만드는 것입니다.  
자동차 게임을 만든다고 생각하면 기본적으로 자동차를 추상화해야 합니다.  
자동차는 바퀴, 창문, 좌석, 브랜드 로고 등으로 이루어져 있습니다. 또한 자동차는 달리거나 멈추거나 후진합니다.  
따라서 자동차는 위와 같은 특성(프로퍼티)과 행위(메소드)를 가지고 있습니다. 이를 코드로 나타내는 것을 추상화라 부릅니다.  
이렇게 추상화된 것을 바탕으로 벤츠의 자동차나 아우디의 자동차가 만들어지는 것을 다형성이라고 볼 수 있습니다.  
오토바이를 만들고 싶다면 자동차의 요소 중 창문은 필요없지만 바퀴나 핸들 등은 필요할 수 있습니다. 
자동차를 추상화한 클래스를 상속받아 오토바이로 만들 수도 있습니다.  
위와 같은 구조의 OOP의 가장 큰 장점은 코드 재사용이다. Car 클래스를 벤츠나 아우디를 만드는데 쓰고, 오토바이를 만드는데도 쓴다.  
벤츠가 고장나면 자동차 클래스를 상속받은 벤츠 클래스의 프로퍼티나 메소드만 수정하면 됩니다. 유지보수에 도움이 됩니다.  
## [객체 지향의 5원칙(SOLID)](http://www.nextree.co.kr/p6960/)
S(Single Responsibility Principle) - 클래스는 존재의 이유와 기능이 독립적이고 명확해 다른 영역에 영향을 끼치지 않는다.  
O(Open Close Principle) - 기능이 추가되어도 기존의 요소는 close, 확장은 open한다.  
L(Liskov Substitution Principle) - 비슷하지만 다른 기능을 하는 요소들은 상위의 치환 클래스를 사용한다.  
I(Interface Segregation Principle) - 인터페이스는 구체적이고 최소한으로 만든다.  
D(Dependencyt Inversion Principle) - 하위 모듈의 변경이 상위 변경을 요구해 컴포넌트간 의존성을 단순화한다.  
## 스택(Stack)과 힙(Heap)
일반적으로 프로그램이 실행되기 위해서는 메모리가 필요하고 이 메모리는 다양한 영역으로 구성되어 있습니다.  
그 중 스택(Stack)과 힙(Heap)이라는 메모리 영역이 존재합니다.  
스택 메모리 영역은 프로그램이 시작되는 시점에 공간을 할당합니다.  
주로 int = 4; 같은 지역 변수 및 함수의 매개 변수 등 데이타 값이 저장됩니다.  
사용된 메모리 공간은 scope가 종료되는 시점에서 반환됩니다.  
힙 메모리 영역은 new 키워드 등이 호출된 시점에 동적으로 할당이 됩니다.  
참조 값(주소)를 가지고 있습니다. 메모리 반환 시점은 프로그래머의 명시(delete) 혹은 gc가 참조하는 값이 없어진 경우에 회수해 갑니다.  
## 함수 시그니처(signature)
컴파일러가 함수를 구분하기 위한 구성 요소를 함수 시그니처라고 부릅니다.  
- 함수명
- 매개변수

이러한 함수 시그니처는 함수 오버로딩의 근간이 됩니다.  
## 가비지 컬렉션(Garbage Collection)
프로그램이 할당 받은 메모리 공간을 효율적으로 관리하는 기법입니다.  
더 이상 사용하지 않는 메모리를 찾아 회수하는 방식으로 메모리를 확보에 프로그램의 최적화하기 위해 사용됩니다.  
일반적으로 동적으로 할당되는 메모리 공간의 경우 그 공간이 지나치게 많아 질 경우 프로그램 전체의 악영향을 끼칠 수 있습니다.  
때문에 프로그래머가 직접 동적으로 가비지가 된 참조 변수를 메모리에서 회수합니다.  
이와 같은 방법은 프로그래머가 회수되는 시점을 명확히 알아야 하고 수동으로 해제해야 한다는 단점이 있습니다.  
하지만 최근 프로그래밍 언어에서는 가비지 컬렉션의 기능을 수행하는 가비지 컬렉터(GC)를 지원합니다.  
따라서 동작하는 방식에 따라 특정 시점에 프로그래머 대신에 쓰레기 수집을 알아서 수행합니다.  
크게 추적 기반(Tracing) 방식과 참조 횟수 카운팅(Reference Counting)의 방식이 존재합니다.  
전자의 경우, 프로그램 실행 중 GC가 할당된 메모리를 모두 조사하여 더 이상 필요 없는 메모리를 마킹 후 해제하는 방식입니다.  
mark-sweep 방식이라고도 불립니다.  
모든 메모리를 검사해야 하므로 오버헤드가 큰 편이고 메모리 변경 시, 다시 마킹해야 해 프로그램 속도 지연에 영향을 끼칩니다.  
이를 보안하기 위해 점진적(Incremental)방식으로 위의 마킹과 해제를 나누어서 수행해 프로그램 속도 지연 시간을 줄이기도 합니다.  
그외에도 세대별(Generation) 방식은 new-old 영역을 구분해 자주 쓰이는 메모리를 old 영역으로 옮겨 자주 쓰이지 않는 new 영역만을 검사해 메모리 조사 영역을 낮춥니다.  
Minor-GC라고도 불리우며 java, js 등에서 사용되는 기법입니다.  
후자의 참조 횟수 카운팅 방식은 메모리의 참조 회수를 카운팅하여 0이 되는 경우 쓰레기라고 인식해 메모리를 해제합니다.  
PHP나 Swift 등의 언어에서 사용되지만 counting의 행위 자체가 오버헤드가 될 수 있고, 상호 참조하는 쓰레기 메모리가 존재할 경우 순환 참조가 되어 메모리 누구가 될 수 있다는 단점이 있습니다.  
## CDN (Content Delivery Network)
origin 서버를 복제하여 클라이언트와 가까운 위치에 서버를 두는 것을 말합니다.  
물리적인 거리(회선)이 짧기 때문에 컨텐츠 전송 시간이 줄어듭니다.  
따라서 네트워크 비용 감소되며 서버 백업 역할도 가능합니다.  
CDN을 서비스하는 회사로는 Akamai, Amazon 등이 있습니다. 
## WebPack
자바 스크립트 코드를 정적 모듈으로 만드는 번들러입니다.  
동작 방식은 exports의 entry부터 내부를 돌며 import, require 등의 의존성을 조사하여 매핑 시키고 그 결과를 output에 번들링된 결과물로 만듭니다.  
일반적으로 JS 프로젝트의 파일 구조 및 의존성이 복잡해지면 여러 개의 파일을 로딩해야합니다.
이는 잦은 네트워크 통신(http1.1 방식)을 유발하는데 웹팩을 사용함으로써 통신이 줄어 들어 속도 향상에 도움이 됩니다.  
파일 단위로 처리하는 로더 뿐만 아니라 번들된 결과물을 처리하는 여러 플러그인은 활용하면 많은 기능을 사용할 수 있습니다.  
예를 들면 UglifyJsPlugin, SourceMapPlugin 등의 플러그인이 있습니다.  
## Spring(스프링)
자바 언어를 기반으로 다양한 애플리케이션을 빠르게 개발하기 위한 프레임워크입니다.  
## 자바 프로그램 실행 로직
main.java를 작성합니다.  
javac로 JVM이 해석 가능한 바이트 코드인 .class를 생성합니다.  
JVM은 .class 묶음들을 읽고 프로세스를 생성하여 OS한테 메모리를 할당 받습니다.  
JVM의 클래스 로더는 프로그램에 의해 호출되는 바이트 코드를 메모리에 적재하고 링킹 및 초기화를 합니다.  
이러한 과정을 거처 OS한테 받은 메모리의 런타임 데이터 영역에 알맞게 데이터가 저장됩니다.  
그 후 실행 엔진은 메모리에 적재된 바이트 코드를 읽고 해석하여 실행하면서 애플리케이션이 수행됩니다.  
## JVM의 구성 요소
JVM은 JRE에 속해 플랫폼에 종속되기 위해 존재하는 일종의 가상 머신입니다.  
데스크탑 x86 아키텍처나 모바일 ARM 아키텍처의 레지스터 기반의 동작이 아닌 스택기반으로 동작합니다.  
### 클래스 로더
클래스 파일을 읽어서 메모리에 적재하고, 필요에 따라 다른 클래스를 링킹하고, 초기화하는 역할을 합니다.   
### 런타임 데이터 영역
OS한테 할당 받은 런타임 영역의 메모리입니다.  
모든 스레드가 공유한다면 쓰레드 세이프하지 않으며 공유하지 않는다면 쓰레드하지 않음을 의미합니다. 
* 매서드 영역(공유) : 클래스 레벨 데이터(static 영역 포함)를 저장하는 영역.   
* 힙 영역(공유) : 모든 객체와 배열이 저장되는 영역.
* 스택 영역(비공유) : 각 스레드마다 가지는 영역, 메서드 호출에 대한 스택 프레임과 로컬 변수가 저장됩니다.   
* PC 레지스터 : 각 스레드는 다른 PC 레지스터를 가지며, 명령 실행 시 현재 실행중인 명령 주소를 저장합니다.  
* 네이티브 메서드 스택 : 네이티브 메서드 정보를 가지는 곳. 모든 스레드에 대해 별도의 네이티브 메서드 스택이 만들어집니다.  

### 실행 엔진
JVM 내의 런타임 데이터 영역에 배치된 바이트코드를 실행하는 역할을 합니다.  
* 인터프리터 : 바이트 코드를 하나씩 읽고 해석합니다. 동일한 바이트 코드도 새롭게 읽는다는 단점이 있습니다.    
* JIT(Just In Time) 컴파일러 : 인터프리터의 단점을 해소하기 위해 반복되는 코드를 발견하면 해당 바이트 코드를 컴파일하여 네이티브 코드로 변경합니다.  
* 가비지 컬렉터 : 더 이상 참조하지 않는 객체를 수집하고 힙 영역에서 제거하는 역할.   

## 서버와 클라의 통신
### req.params
URL에서 변수로 넘어온 값
어떤 대상 자체를 조회/수정/삭제할 때 파라미터로 대상의 id를 전달합니다.  
예) public_IP/articles/123→ articles/:idreq.params.  id 에는123이담겨있음.  
### req.query
URL에서 쿼리 문자열로 넘어온 값
어떤 대상의 속성을 가지고 대상을 조회할 때 쿼리문자열로 속성을 전달합니다.  
예) GET public_IP/articles?writer=‘정원희’&department=‘server’
→ req.query.writer, req.query.department로 가져옵니다.
### req.body
body로 넘어온 값.  
어떤 대상을 새로 저장 / 수정할 때 body로 저장 / 수정할 값 을 전달합니다.  
예) { writer: ‘정원희’, department: ‘server’ }
→ body-parser를 이용하여 req.body.writer, req.body.department로 가져옵니다.

#### GET
URL 혹은 URI에 변수를 포함 시켜(물론 안 할 수도 있음) 데이터를 받는 방식입니다.  
따라서 url에 입력한 데이터가 그대로 노출됩니다.  
한 번의 GET 요청 당 전송 가능 데이터 양은 255자(주소 + 파라미터)입니다.  
주소-값 파싱 연산자 ?를 기준으로 '이름=값'의 쌍으로 이루어진 쿼리로 데이터를 서버에 보냅니다.  
위와 같은 특징으로 인해 GET은 주로 서버에서 데이터를 가져와 값이나 상태 등을 변경하지 않고 보여줄 때 사용합니다.  
#### POST
데이터를 Body(일종의 객체)에 감싸서 보내는 방식입니다.
따라서 url에 데이터가 노출되지 않습니다.
한 번의 POST 요청 당 많은 양의 데이터를 전송할 수 있습니다.
따라서 POST는
서버 데이터의 값이나 상태를 변경하기 위해 사용합니다.
### PUT
POST와 마찬가지로 Body에 감싸서 보내는 방식입니다.  
성공적으로 보내면 데이터가 업데이트 됩니다.  
### DELETE
성공적으로 보내면 데이터가 삭제됩니다.  
### 패킷
HTTP 프로토콜의 GET, POST 메서드 등을 통해 보낸 데이터를 HTTP 패킷이라고 합니다.
이 패킷은 Header-Body로 구성되어 있습니다. Url에 노출되는 GET은 데이터를 헤더에 그렇지 않은 POST는 바디에 담아서 보냅니다.
### GET과 POST의 차이
클라이언트가 보내는 정보가 패킷의 헤더에 넣느냐 바디에 넣느냐의 차이점이 있습니다.  
흔히 GET 방식에서의 데이터 전송이 URL에 붙어서 가기 때문에 보안에 약하다고 하지만,  
POST 방식 역시 크롬 개발자 도구의 network 탭 조작만으로도 조회가 가능하기 때문에 보안에 좋다고 볼 수는 없습니다.  
GET 방식의 경우, 웹 브라우저가 캐싱을 하기 때문에 POST 방식보다 속도가 빠를 수 있다 볼 수 있습니다. 
## 웹브라우저의 캐시 동작
웹 브라우저가 캐시를 한다면 서버에 불필요한 요청을 줄여 네트워크의 비용을 절감하고 웹 페이지의 빠른 로딩 효과를 얻을 수 있습니다.    
무엇을 어떻게 캐싱할 것인가에 대한 정보는 HTTP req/res Header에 담을 수 있을 수 있습니다.    
주로 사용되는 HTTP 헤더로 Cache-Control과 ETag가 있습니다.    
Cache-Control는 파라미터를 통해 캐싱 방식을 전달합니다.  
- no-cache / no-store : 캐시 사용 안함 / ETags 사용 안함
- public / private : 공개적 캐싱 / 유저당 캐싱
- max-age : 캐시의 유효시간 (sec)
ETag는 캐시된 리소스에 대한 체크를 위한 헤더입니다.  
랜덤 스트링으로 할당된 값을 통해 revision을 체크합니다.  
## ASCII와 UniCode
컴퓨터가 정보를 처리하는 기본 단위는 byte입니다.  
byte는 8개의 bit로 구성됩니다.  
bit는 컴퓨터가 사용하는 최소 단위로 0 혹은 1로 존재합니다.  
따라서 1 byte는 256개의 정보를 가질 수 있습니다.  

컴퓨터가 A라는 문자를 저장하기 위해서는 '문자 인코딩' 혹은 '부호화'를 해야합니다.  
반대로 10101010라는 정보를 문자로 복원하는 것을 '복호화'라고 합니다.  

ASCII는 표준 부호 체계입니다.  

1byte(8bits) 중 7개의 비트를 사용합니다.   나머지 1개의 비트는 통신 에러 검출을 위한 parity bit로 사용합니다.  
따라서 총 128개의 고유 값을 사용할 수 있습니다.  

https://www.ascii-codes.com/에서 확인할 수 있습니다.  

그러나 ASCII 코드는 미국에서 정의하였기 때문에 다소 알파벳 위주입니다.   
다른 언어를 표현하기에 7bit로는 부족했기 때문에 등장한 것이 8bit로 확장한 ANSI 코드입니다.   
ASCII의 7비트를 그대로 사용하고 나머지 1비트를 codepage로 사용해 표현하였습니다.  

한글은 자음과 모음의 조합 가능 개수가 128개를 넘습니다.  
따라서 전세계 모든 문자를 일관되게 표현하기 위해 고안된 코드 조합이 unicode 입니다.  
http://unicode.org/charts/PDF/UAC00.pdf에 따르면 '가'는 U+AC00입니다.   

이러한 유니코드를 컴퓨터가 알아 듣기 위해서는 문자 인코딩이 필요합니다.  
utf-8이라는 문자 인코딩 방식은 전 세계에서 사용하는 일종의 약속입니다.  
8비트 숫자의 집합으로 모든 문자를 변환하는 것입니다.  
16비트의 숫자 집합으로 나타내는 utf-16도 존재합니다.   
변환 되는 내부 과정은 생략하겠습니다.  

일반적으로 데이터베이스의 character-set을 utf8로 사용하는 경우 collation을 utf8_general_ci와 utf8_unicode_ci를 사용합니다.  
utf8_unicode_ci는 정확한 값을 요구할때, utf8_general_ci는 뛰어난 성능을 요구할때 선택하여 사용합니다.  

## URL vs URI
URI(uniform resource identifier)란 인터넷에 자원을 나타내는 주소 식별자라고 볼 수 있습니다.  
URI의 표현 방식에 따라 URL, URN 등이 있습니다.  
URL(uniform resource locator)은 아래와 같이 구성됩니다.  
프로토콜: http://  
도메인: www.naver.com  
자원을 식별할 수 있는 자원의 경로명:  /news/sports/main.html  
URL은 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알수 있지만 반대로 경로가 바뀐다면 접근할 수 없다는 단점이 있습니다.  
이에 따라 등장한 URN은 불변의 의미를 가지는 이름으로 인터넷 자원을 나타냅니다.  
아직 표준으로 채택되지도 개발도 완전히 진행되지는 않았다고 합니다.  

## HTTP 응답 상태 코드
2xx - 성공 : 200번대의 상태 코드는 대부분 성공을 의미합니다.
* 200 : GET 요청에 대한 성공
* 204 : No Content. 성공했으나 응답 본문에 데이터가 없음
* 205 : Reset Content. 성공했으나 클라이언트의 화면을 새로 고침하도록 권고
* 206 : Partial Conent. 성공했으나 일부 범위의 데이터만 반환

3xx - 리다이렉션
300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우입니다.
* 301 : Moved Permanently, 요청한 자원이 새 URL에 존재
* 303 : See Other, 요청한 자원이 임시 주소에 존재
* 304 : Not Modified, 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐싱된 자원을 사용하도록 권고. ETag와 같은 정보를 활용하여 변경 여부를 확인

4xx - 클라이언트 에러
400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우입니다. 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생합니다. 가장 익숙한 상태 코드는 404 코드입니다. 요청한 자원이 서버에 없다는 의미죠.
* 400 : Bad Request, 잘못된 요청
* 401 : Unauthorized, 권한 없이 요청. Authorization 헤더가 잘못된 경우
* 403 : Forbidden, 서버에서 해당 자원에 대해 접근 금지
* 405 : Method Not Allowed, 허용되지 않은 요청 메서드
* 409 : Conflict, 최신 자원이 아닌데 업데이트하는 경우. ex) 파일 업로드 시 버전 충돌
5xx - 서버 에러
500번대 상태 코드는 서버 쪽에서 오류가 난 경우입니다.
* 501 : Not Implemented, 요청한 동작에 대해 서버가 수행할 수 없는 경우
* 503 : Service Unavailable, 서버가 과부하 또는 유지 보수로 내려간 경우

## Proxy와 VPN
프록시 서버는 클라가 서버에 요청을 보낼 때 중개해주는 서버입니다.  
클라 - 프록시 - ISP - 서버
따라서 서버에는 중개 서버의 IP만 알 수 있으므로 차단된 사이트에 우회 접속하는 용도로 사용되곤 합니다.  
프록시는 서버에서 보내주는 응답을 해석하여 클라에게 전달해주지만 이러한 과정에서 발생하는 시간 비용을 줄이기 위해 VPN라는 서비스가 등장했습니다.  
클라 - VPN(암호화) - ISP - VPN(복호화) - 서버 사이에 가상 회선을 만들어 프록시처럼 IP 변경이 가능한 방식입니다. 

## GSLB
DNS : 도메인 이름을 IP 주소로 변환하는 서비스를 제공합니다.
각 DNS 서버는 클라한테 받은 요청을 RR 방식으로 처리합니다.  
2개의 서버가 있을때 4명의 요청이 있다면 2개, 2개씩 할당됩니다.  
따라서 한 서버가 다운 되면 50%의 이용자는 여전히 다운된 서버로 요청을 보냅니다.  
부하 상태, RTT, 물리적 거리 또한 알 수 없습니다.
GSLB : 주기적으로 서버의 상태를 체크(health check)하고 lb를 수행하는 SLB에 지리적 개념을 확장 적용합니다.
1. www.naver.com으로 클라이언트가 DNS 서버에 요청
2. DNS는 GSLB에게 질의
3. GSLB는 각 서버의 health check 수행 후 DNS에게 IP 전달
4. DNS는 클라에게 IP 전달



## 스케줄링
OS가 프로세스에게 자원을 부여하여 진행 순서를 정하는 것입니다.  
목적은 오버헤드/응답/반환/대기시간을 최소화해 CPU 이용률을 높이고 많은 처리량을 위함입니다.  
선점 스케줄링 -> 경우에 따라 프로세스에게 부여된 자원을 회수하여 새로운 프로세스에게 부여하는 방식으로 빠른 응답시간을 요하는 시스템에 적합합니다.  
스케줄러 호출이 잦고 문맥 교환에 의한 오버 헤드가 발생할 수 있습니다.  
비선점 스케줄링 -> 한번 할당한 자원에 대하여 회수하지 않기 때문에 한 번에 처리해야 하는 시스템에 적당합니다.  
하나의 프로세스가 짧은 프로세스들을 오랫동안 대기시킬 수 있다는 단점이 있습니다.

## 비선점형 스케줄링 알고리즘
FIFO -> 큐와 같은 방식으로 무조건 먼저 들어온 처리합니다.
SJF -> CPU 점유 시간이 짧은 프로세스부터 처리하는 방식입니다.
HRN -> 우선순위공식을 이용하여 실행 순서를 정합니다. 우선순위 = (대기+서비스)/서비스

## 선점형 스케줄링 알고리즘
SRT -> SJF의 선점 형태로, 중요한 프로세스는 자원을 선점하여 먼저 수행할 수 있습니다.
RR -> 시간 단위로 자원을 할당해 많은 프로세스의 응답을 빠르게 할 수 있습니다.
MLQ -> 다단계의 큐를 둬서 0순위 큐부터 프로세스에 자원을 할당합니다.
MLFQ -> MLQ에 에이징 기법을 도입해 기아를 방지합니다.
